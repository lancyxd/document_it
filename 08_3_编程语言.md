# 1、GO

[GO知识图谱](https://www.processon.com/view/link/5a9ba4c8e4b0a9d22eb3bdf0#map)

[godoc文档](http://docscn.studygolang.com/pkg/)

https://godoc.org/

### 1.1 基本语法

- **概括**

  ```go
  代码规范（变量、文件目录、包等命名规范；级别：必须遵循)：
  全局变量：对外暴露的全局变量使用大驼峰，包内使用的全局变量使用小驼峰;   局部变量：小驼峰;
  文件、目录：unix风格，小写字母和下划线_拼接构成; a_file
  包：全部使用小写字母，不建议下划线；不同功能同一大类别package建议使用多级目录，进行子包隔离; 
  大驼峰：首字母大写，混合使用大小写字母来构成变量和函数的名字 ;MixedCap
  小驼峰：首字母小写，混合使用大小写字母来构成变量和函数的名字;mixCap
  除非必要，不建议使用JSON库中的omitempty标签
  
  包与包之间不可以循环导入
  快捷键：    Ctr+/注释    Ctr+R build and run
  大写开头包外可见，小写开头包内可见 ；变量或函数的首字母大写 的时候，在包外部可见， 或者说公有的 ；  公有函数的名字以大写字母开头；私有函数的名字以小写字母开头。  
  导入的包可以随意命名；
  标识符名的第一个字符为Unicode大写字母（Unicode类别“Lu”）；
  该标识符在包块中已声明或为字段名或方法名。
  <-libutil.ChanRunning防止main函数退出
  kafka初始化失败会自动重新连接，一般continue;不用return
  ```

- **go语法**

  ```go
  Go语言的工作空间为文件目录，目录中必须包含src、pkg、bin三个目录。bin存放编译后的可执行文件；pkg存放编译后的包文件；src存放项目源文件。一般，bin和pkg目录可以不创建，go命令会自动创建（如 go install），只需要创建src目录即可。
  GOROOT：go源码包目录；GOPATH：本人开发项目所在的目录；GOPATH下会有3个目录：src, bin, pkg。
  src目录：go编译时查找代码的地方
  bin目录：go get godep这种bin工具的时候，二进制文件下载的目的地
  pkg目录：编译生成的lib文件存储的地方。
  
  go build (切换到对应文件下，直接执行，生成的可执行程序即为文件夹名)
  go build filename.go (执行./filename，./代表当前目录)
  go run filename.go(编译并执行)
  
  Go 语言中 main() 和 init() 函数都不能有返回值
  一个工程中允许存在多个init函数，先执行init函数，再执行main函数。
  _ "net/http/pprof"  它会引入包，先调用包中init()，该方式仅让导入的包做初始化，而不使用包中其它函数。
  for _,v := range Slice{} // 表示丢弃索引值。
  _, err := func() // 单函数有多个返回值，用来获取某个特定的值，其他值不获取
  
  type Foo interface {
       Say()
  } //接口
  type Dog struct {
  }//结构体
  var _ Foo = Dog{} //判断Dog是否实现Foo这个interface,用作类型断言，若Dog没有实现Foo，则报编译错误
  
  变量声明 var v1 int = 10 //关键字var存在，类比C语言，变量名和类型互换；
  交换两数i, j = j, i； 常量声明：const pi float64 = 3.14
  预定义常量：iota一个可被编译器修改的常量
  make、new区别：make用于内建类型（map、slice和channel）的内存分配。make返回初始化后的（非零）值T。
  new用于各种类型的内存分配。new(T)分配了零值填充的T类型的内存空间，并且返回其地址，new返回指针*T。
  //创建一个初始元素个数为5的数组切片，元素初始值为0，并预留10个元素的存储空间  
  b := make([]int, 5, 10) //func make([]T, len, cap) len长度，cap可选的容量参数。[0 0 0 0 0]
  b = b[1:]      // len(b)=4, cap(b)=4
  var imgId interface{}
  imgId:="12345"
  imgId.(string) // 将imgId转换为string    字符串和int互转函数:Atoi  Itoa 
  string([]byte("123"))
  
  map 在使用之前必须用 make 而不是 new 来创建；值为 nil 的 map 是空的，并且不能赋值。
  map是无序的，每次打印都不一样，只能通过key获取。内置方法len返回map的key的数量。
  声明一个Arraymap；一个rmap；给rmap赋值；采用append函数追加至Arraymap（append循环内部）。
  
  匿名函数：没有实际名字的函数，都是Function对象。作用：在go语言中目前了解的作用就是用于构成闭包。
  go func{}()使用关键字go很容易实现并发编程，其花括号后面跟小括号，(小括号代表执行)；其属于匿名函数。
  func no_func() {
     //匿名函数1:有参数，返回值为int
     f := func(i, j int) (result int) {
        result = i + j
        return result
     }
     fmt.Fprintf(os.Stdout, "f = %v  f(1,3) = %v\n", f, f(1, 3))
     //匿名函数2
     func(i, j int) (m, n int) {
        return j, i
     }(1, 9) //创建匿名函数并执行
     //匿名函数3
     a := func(args int) int {
        fmt.Println("excute")
        return 5
     }(3) //先赋给变量a，然后再调用
     fmt.Println("func args a:", a)
     //匿名函数4
     var j int = 5
     acomplex := func() func() {
        var i = 10
        return func() {
           fmt.Printf("i=%d,j=%d\n", i, j)
        }
     }() //末尾括号表名函数被调用，并将返回的函数指针赋给变量acomplex
     fmt.Println(acomplex)
     acomplex()
     j = j * 2
     acomplex()
  }
  
  闭包	https://www.cnblogs.com/cxying93/p/6103375.html
  闭包主要涉及到js的几个其他的特性:作用域链,垃圾(内存)回收机制,函数嵌套,等等。闭包是由函数及其相关引用环境组合而成的实体(即：闭包=函数+引用环境)。闭包价值：但是如果有闭包的话，闭包会保存外部函数的活动对象（变量），所以如果不把对闭包的引用消除掉，闭包会一直存在内存中，垃圾收集器不会销毁闭包占用的内存。
  func A() func(int) int {
     sum := 0
     return func(x int) int {
        sum += x
        return sum
     }
  }
  
  func main() {
     a := A()
     b := a(4)
     fmt.Println(b)
  }
  
  defer和pannic、recover为go的异常处理，跟java中的try catch finially是类似的。
  （panic抛出异常，recover捕获异常，recover只能在defer语句中使用，直接调用recover无效）
  defer：简化资源回收（defer确实是在return之前调用的）;执行顺序后进先出；
  defer、return、返回值三者的执行逻辑应该是：return最先执行，return负责将结果写入返回值中；接着defer开始执行一些收尾工作；最后函数携带当前返回值退出。
  panic("触发异常")之后，程序退出，其后的defer语句是无法执行的。
  panic捕获异常；return之后修改函数返回值；安全的回收资源
  recover()函数可以用于获取/拦截panic。仅当在一个defer函数中被完成时，调用recover()将会完成这个小技巧。
  func main() {
     //defer_call()
     defer func() {
        fmt.Println("defer func  1")
        if err := recover(); err != nil {
           fmt.Println("defer func recover捕获异常", err) //err为panic传入的内容
        }
        fmt.Println("defer func 2")
     }()
  
     RevDef()
  }
  
  func RevDef() {
     for {
        fmt.Println("RevDef 1")
        panic("panic异常")        //生成panic文件，此时程序跳转到defer
        fmt.Println("RevDef 4") //不会运行
        time.Sleep(1 * time.Second)
     }
  }
  
  func defer_call() int {
     panic("触发异常")
     defer func() { fmt.Println("打印前") }()
     defer func() { fmt.Println("打印中") }()
     defer func() { fmt.Println("打印后") }()
     return 0
  }
  
  // 传值和传指针区别
  Go使用的*、&、new()这些运算符，和C++的用法完全一样。有传值和传引用/传地址的概念，和C++一样。
  Go没有new对应的delete操作，而是采用Java一样的垃圾自动回收机制。传引用或指针主要用于用户自定义类型。
  传值:实际传了值的copy，当在被调函数中修改参数值时，调用函数中相应实参不会变化，数值变化只作用在copy上。
  传指针：比较轻量级 (8bytes),只传内存地址。当传递大的结构体的时候，用指针是一个明智的选择。
  Go语言中string，slice，map这三种类型的实现机制类似指针，所以可以直接传递，而不用取地址后传递指针。（注：若函数需改变slice的长度，则仍需要取地址传递指针）
  func main() {
     i := 10
     pass_by_value(i)
     fmt.Println("pass_by_value:", i) //10
     pass_by_reference(&i)
     fmt.Println("pass_by_reference:", i) //100
  
     x := new(int)
     *x = 5
     fmt.Println("new *x:", *x) //5
     pass_by_reference(x)
     fmt.Println("pass_by_reference:", *x) //100
  }
  
  func pass_by_value(i int) {
     i = 100
  }
  func pass_by_reference(i *int) {
     *i = 100
  }
  
  // channel、select、signal用法
  channel即通道，可以执行数据的发送(Send)和接受(Receive)。在不同的goroutine之间通信或共享数据，有默认的deadlock检测机制。chan在使用make初始化时可附带一个可选参数来设置缓冲区。默认无缓冲，若是无缓冲区的chan，这样只有写入的元素直到被读取后才能继续写入，不然就一直阻塞。（有接受者才去放ch<-elem，没有接收者就会阻塞）
  设置缓冲区大小后，写入数据时可连续写入到缓冲区中，直到缓冲区被占满。从chan中接收一次便可从缓冲区中释放一次。可以理解为chan是可以设置吞吐量的处理池。
  chan可以与select相结合，chan会变成非阻塞的。
  c := make(chan int,3) //带缓冲
  c := make(chan int)  //无缓冲
  c <- 42//不带缓冲,不启携程会阻塞，42发送至到chanel c；
  v := <-c //从channel中读取数据，并将数据赋值给v
  
  // golang的多态必须借助于接口来实现。 参考链接：https://studygolang.com/articles/5054
  接口interface。效果上类似于C++多态的概念,在最终效果上，它实现了多态的影子。在Go语言中，一个类只需要实现了接口要求的所有函数，我们就说这个类实现了该接口。(非侵入式接口，除去繁杂的继承体系。golang不支持完整的面向对象思想，它没有继承，多态则完全依赖接口实现。golang只能模拟继承，其本质是组合，只不过golang语言为我们提供了一些语法糖使其看起来达到了继承的效果。)
  
  goroutine并发
  并行:两个cpu上两个任务并列运行
  并发:一个cpu上多个任务交替运行
  Goroutine协程，并不是真正意义的线程，可理解为一种轻量级的线程（或微线程），用关键字go作为开头。它基本上是一种分配在同一个地址空间内的，能够并行执行的函数，可以在同一个地址空间中与其他goroutines并发运行。 它们在O.S.线程中进行多路复用，因此，如果一个块被阻塞，其他线程可以继续。所有的同步和内存管理都是通过Go进行的。它们不是真正的线程的原因是它们并不总是并行的。但是，由于多路复用和同步，您会得到并发行为。
  要启动一个新的goroutine，只需使用"go"这个关键字。（并行是关于性能的设计；并发是关于程序的设计）
  不等待goroutine的执行，main程序会立刻终止，任何正在执行的goroutine都会停止。
  go channel：在goroutines之间传递内存的通道。
  Channels与goroutine通讯的机制（通过 select（和其他东西）可以监听 channel 上输入的数据。
  
  // json Marshal Unmarshal参考代码即可
  // 打tag标签，标签冒号前是类型，后面是标签名。
  `json:"-"` // 表示不进行序列化
  `json:"product_id,omitempty"`//序列化加omitempty，忽略0值或者空值
  Number int `json:"number,string"`//结构体类型不一致时，可以指定结构体类型。支持string,number和boolean
  omitempty标签：就是说如果有一个属性是空的值，就不会出现在JSON结果中
  
  
  
  
  使用 http 请求第三方接口时，如果丢弃 response，那么 response 的 body 系统不会帮你 close，所以会导致很多的 time_wait，然后内存会缓慢上升。
  ```

  ![08_03go结构体](./image/08_03go结构体.png)

  

  ![go函数](./image/08_03go函数.png)



![08_03数组](./image/08_03go数组.png)



![08_03gochannel](./image/08_03gochannel.png)



![08_03gosignal](./image/08_03gosignal.png)



![08_03goGmax](./image/08_03goGmax.png)

![08_03goGMax1](./image/08_03goGMax1.png)

![08_03go匿名](./image/08_03go匿名.png)

![08_03goflag](./image/08_03goflag.png)

### 1.2 go常见坑

```go
在代码中所有声明的变量都需要被用到，当然，全局变量除外。函数的参数也可以只被声明，不被使用。
import _ 包路径，只是引用该包，仅仅是为了调用init()函数。
隐式变量（作用域）：一个变量的作用范围仅仅是一个代码块。
除非特别指定,无法用nil给变量赋值。nil 可以用作 interface、function、pointer、map、slice 和 channel 的“空值”。
自增和自减：仅支持i++
map遍历(输出顺序随机)
以小写字母开头的结构体将不会被（json、xml、gob等）编码。
传值方法的接收者无法修改原有的值:声明为值，那么你的函数/方法得到的是接收者参数的拷贝。对接收者所做的修改将不会影响原有的值，除非接收者是一个map或者slice变量，而你更新了集合中的元素，或者你更新的域的接收者是指针。
json数据反解至结构体和map均可以
数组为值的属性很有用，但代价高昂；若你想要 C 那样的行为和效率，你可以传递一个指向该数组的指针。
每个文件都可以拥有多个 init 函数。
slice 和 map 的 nil 值：初始值为 nil 的 Slice 是可以进行“添加”操作的，但是对于 Map 的“添加”操作会导致运行时恐慌。(Map的添加一定要初始化)
golang的nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。在golang中，nil只能赋值给指针、channel、func、interface、map或slice类型的变量。
修改原数组的数据，需要使用数组指针（array pointer）或使用 slice
string无法修改，可以采用byte slice
Rune 是 int32 的别名。用 UTF-8 进行编码。例如需要遍历字符串中的字符
判断字符串是否为utf8 utf8.ValidString(str1)
在多行的Slice、Array和Map语句中遗漏逗号
按位not
         var d uint8 = 2
         fmt.Printf("%08b\n", d)  //00000010
         fmt.Printf("%08b\n", ^d) //11111101,^取反操作符
 失败的类型断言
         var data interface{} = "great"
         fmt.Println(reflect.TypeOf(data)) //打印data类型
         res, ok := data.(int)             //判断data是否为int类型  res: 0 ok: false
 json中tag标签
json marshal后为字符串;json unmarshal反解到定义的结构体或mapping中
tag标签：
`json:"index_list,omitempty"` //若该字段为空，json marshal后不出现index_list这个字段
`json:"index_list"` //若该字段为空，json marshal后依旧出现出现index_list这个字段
获取MD5
appid是用来标记你的开发者账号的
appkey:两次md5(加上appid)
func MD5(b []byte) string {
         h := md5.New()
         h.Write(b)
         x := h.Sum(nil)
         y := make([]byte, 32)
         hex.Encode(y, x)
         return string(y)
}
  有一个struct值的map
         m := map[string]data{"x": {"one"}} // map[x:{one}]
         r := m["x"]
         r.name = "two"
         m["x"] = r
         fmt.Printf("%v\n", m) //prints: map[x:{two}]
 
         pm := map[string]*pdata{"x": {"one"}}
         fmt.Println("pm:", pm)
         pm["x"].name = "two"
         fmt.Println(pm["x"].name) //two
```



### 1.3 go tool命令

[go命令](https://wiki.jikexueyuan.com/project/go-command-tutorial/0.1.html)

```go
go工具目录:$GOROOT/pkg/tool/<平台相关目录>
go vet 代码静态检查发现可能的bug或者可疑的构造。（go vet exercise.go或go tool vet）
go build命令用于编译我们指定的源码文件或代码包以及它们的依赖包
go build(进入logging包，直接执行)
go build common/logging(在任意目录执行)
go build 用法( go build -h 或 go help build 查看)
go build -gcflags “-N -l” 关闭内联优化
go build -gcflags '-l' -o interface11 interface11.go
go build -ldflags //隐藏所有代码实现相关的信息
go tool objdump -s "operate\.Login" server //转换为汇编语言（解析可执行文件server，将其中的 operate 包的 Login 方法转成汇编代码。）

go install安装编译后的结果文件到指定目录
go fmt exercise.go 格式化文档

go get可以根据要求和实际情况从互联网上下载或更新指定的代码包及其依赖包，并对它们进行编译和安装。
go get github.com/astaxie/beego
go get -v -u -x github.com/astaxie/beego
go get -u github.com/astaxie/beego
git https 无法获取，请配置本地的 git，关闭 https 验证：git config --global http.sslVerify false

go clean命令会删除掉执行其它命令时产生的一些文件和目录
go clean -x -i m_search/bulk_inserter

go doc命令可以打印附于Go语言程序实体上的文档
go doc http.Request

godoc是一个很强大的工具，同样用于展示指定代码包的文档
godoc fmt Printf Println
godoc fmt
godoc -ex net/http FileServer

go run命令可以编译并运行命令源码文件
go run -n dd1.go 
go run dd1.go 

go list命令的作用是列出指定的代码包的信息
go list common/logging

go tool pprof命令来交互式的访问概要文件的内容
????

go tool cgo

go env命令可打印出的Go语言通用环境信息

go test
采用go test命令。编写even_test.go函数，来测试even.go中函数的正确性
```

### 1.4 其它(proto,thirft等)

- **Protobuffer（基于二进制，消息表示高效简洁）**

  [gRPC之proto语法](https://www.jianshu.com/p/da7ed5914088)

  [Golang + Protobuf 构造通讯协议](https://www.jianshu.com/p/669184a95c7c)

  ```shell
  Protobuf好处：可以保证同一消息报文新旧版本之间的兼容性。作用：和XML差不多，即把某种数据结构的信息，以某种格式保存起来。主要用于数据存储、传输协议格式等。是一种轻便、高效的结构化数据存储格式，可以用于结构化和数据串行化，很适合做数据存储和rpc数据交换。ProtoBuf对小数据有效。
  
  # Protocol buffer使用步骤
  1)创建.proto文件，相当于确定数据协议，数据结构中存在那些数据，数据类型怎样
  创建扩展名为. proto文件，如：MyMessage.proto，并将以下内容存入该文件中。通过Protocol Buffer编译工具，可以将每个.proto文件生成出一对.h和.cc的C++代码文件。最终文件组成：如：MyMessage.proto生成的文件为MyMessage.pb.h和MyMessage.pb.cc。
  2)命令行编译工具解析：
  protoc --proto_path=IMPORT_PATH --cpp_out=DST_DIR --java_out=DST_DIR --python_out=DST_DIR
  path/to/file.proto
  例子：protoc --go_out=. *.proto
  protoc为Protocol Buffer提供的命令行编译工具；
  --proto_path等同于-I选项，主要用于指定待编译的.proto消息定义文件所在的目录；
  --cpp_out选项表示生成C++代码，--java_out表示生成Java代码，--python_out则表示生成Python代码，--go_out则表示生成go代码，其后的目录为生成后的代码所存放的目录；path/to/file.proto表示待编译的消息定义文件。
  3). proto文件解析
  message是消息定义的关键字；（数据协议以message形式表现出来）
  required前缀表示该字段为必要字段；
  repeated主要用于表示数组字段（可重复字段）；
  optional可选字段，可删除，可以不初始化。
  import消息定义文件可以通过import的方式将该文件中定义的消息包含进来;
  import "myproject/CommonMessages.proto"
  4)Packages
  我们可以在.proto文件中定义包名，如： package ourproject.lyphone;该包名在生成对应的C++文件时，将被替换为名字空间名称，既namespace ourproject { namespace lyphone}
  
  用法举例（参考route_server）
  demo：https://www.cnblogs.com/jkko123/p/7161843.html，现在是3.多版本
  创建test.proto文件（导入包即为package test，有分号）；
  protoc --go_out=. test.proto，生成test.pb.go文件；
  ./protoc --go_out=. *.proto编译全部的proto文件（备注：一定要切换到proto文件所在目录下）
  ```

  ![08_03goProto.png](./image/08_03goProto.png)

  

- **Thrift(一款高性能、开源的 RPC 框架）**

  [Thrift学习笔记—IDL基本类型](http://my.oschina.net/helight/blog/195015)

  [Golang RPC 之 Thrift](https://studygolang.com/articles/9607)

  [Golang通过Thrift框架完美实现跨语言调用](http://www.open-open.com/lib/view/open1380527669353.html)

  ```shell
  生产中用的最多的IDL是Google开源的protobuf。最常见的是Facebook开源的Thrift RPC框架。
  用于描述通讯协议的方式很多，xml,json,protobuf，thrift；两种目前在大型系统中，应用比较普遍的两种通讯框架，thrift和Protobuf；采用RPC（Remote Procedure Call Protocol）编程，RPC被认为是在分布式环境中运行的客户机和服务器应用程序之间进行可靠通信的最强大、最高效的方法之一；属于跨语言通讯框架；
  1) RPC（Remote Procedure call）远程过程调用 RPC是两个在不同物理机上的进程之间的通信。即是在一台机器上调用另一台机器的方法。RPC是一种C/S架构的服务模型，server端提供接口供client调用，client端向server端发送数据，server端接收client端的数据进行相关计算并将结果返回给client端。RPC工具大多使用"接口描述语言" (IDL:interface description language) 来提供跨平台跨语言的服务调用。 
  2)Thrift通过一个中间语言(IDL接口定义语言)来定义RPC的接口和数据类型，然后通过一个编译器生成不同语言的代码（目前支持C++,Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, Smalltalk和OCaml）, 并由生成的代码负责RPC协议层和传输层的实现。
  
  # 利用Thrift用户只需要做三件事：
  a)利用IDL定义数据结构及服务;
  b)利用代码生成工具将(1)中的IDL编译成对应语言（如C++、JAVA），编译后得到基本的框架代码;
  c)在(b)中框架代码基础上完成完整代码（纯C++代码、JAVA代码等）
  
  # 举例说明
  1)定义 Thrift RPC 接口，创建thriftport.thrift文件
  2)编译
  thrift -out . --gen go example.thrift，就会在 thrift_file 的同级目录下生成 golang 的包：example，其中 format_data-remote 是生成的测试代码可以不用特别关注
  3)创建client目录，server 目录进行thrift测试
  client目录下的 client.go 实现了客户端用于发送数据并打印接收到 server 端处理后的数据
  server 目录下的 server.go 实现了服务端用于接收客户端发送的数据，并对数据进行大写处理后返回给客户端
  thrift_file 用于存放 thrift 的 IDL 文件： *.thrift
  先启动server,再启动client。
  ```

  ![08_03goThrift.png](./image/08_03goThrift.png)

  

- **go module**

  [go module 基本使用](https://www.cnblogs.com/chnmig/p/11806609.html)

  ```go
  go module可以将某个项目(文件夹)下的所有依赖整理成一个 go.mod 文件,里面写入了依赖的版本等。
  on/off/auto
  set GO111MODULE=on  windows
  export GO111MODULE=on  linux/mac  暂时有效
  go env -w GO111MODULE=on   永久生效
  
  go mod init test(test为项目名)  # 项目根目录会出现一个go.mod文件，仅标识了go的版本号
  go mod tidy   # 检测依赖 tidy会检测该文件夹目录下所有引入的依赖,写入 go.mod 文件
  ```

- 











## 2、python

[python3文档内容](https://docs.python.org/zh-cn/3/contents.html)

[十五分钟让你了解Python套路](https://www.jianshu.com/p/36ae91c38279)

python特性是动态语言

### 2.1 基本语法

```python
交互式编程：不需要创建脚本文件，在命令行中输入python。（ll /usr/bin/python*）
执行脚本文件：python test.py     ./test.py
魔术字符串：#!/usr/local/bin/python（帮你在系统搜索中找到指定python解释器路径）
# -*- coding=utf-8 -*-，允许使用中文或者其它非ASCII码
UNIX下，python解释器的路径一般为/usr/local/bin/python或/usr/bin/python
查看版本：python3 -V		 sys.version
Python对对空格和缩进很敏感；一句话有冒号的下一行往往要缩进，该缩进就缩进；变量赋值不需要类型声明；括号在pyhton中不是必须的；
pass是空语句，是为了保持程序结构的完整性。一般用作占位语句
break（跳出整个循环）和continue（跳出本次环，继续执行下一轮循环）
退出系统：exit()   ctrl+D退出 ctrl+z     sys.exit()
在同一行中使用多条语句，语句之间使用分号;分割
注释（推荐四个空格缩进）：多行 '''注释内容'''或者"""注释内容"""  单行 #注释内容
模块的搜索路径:先在当前目录中搜索，如果找不到，则在sys.path变量中给出的目录列表中查找。sys.path（输入脚本的目录（当前目录）;环境变量 PYTHONPATH 表示的目录列表中搜索;Python 默认安装路径中搜索。
（临时生效）：动态增加路径sys.path.append(‘/home/wang/wokespace’)     
（永久生效）vim ~/.bashrc，将内容export PYTHONPATH=$PYTHONPATH:/home/wang/workspace 附加到文件末尾，修改PYTHONPATH变量。
包：将文件夹当做模块，目录中必须包含 __init__.py 文件
ASCII编码和unicode编码区别：ASCII编码是1个字节，而Unicode编码通常是2个字节；字母A用ASCII编码是十进制的65，二进制的01000001；A的Unicode编码是00000000 01000001
bytes和str两种类型转换的函数encode(),decode(),str通过encode()可以编码为指定的bytes。若从网络或磁盘上读取了字节流，则读到的数据就是bytes。bytes变为str，用decode()方法
'/'和‘//’的区别：只有一个反斜杠，会输出完整运算结果;两个反斜杠时，只输出整数。5/2  2.5  5//2  2
5**2=25

if __name__ == '__main__'的意思是：当.py文件被直接运行时，if __name__ == '__main__'之下的代码块将被运行；当.py文件以模块形式被导入时，if __name__ == '__main__'之下的代码块不被运行。



b'hello'    python对bytes类型的数据用带b前缀的单引号或双引号表示
x = b'xxx'转换为真正的（Unicode）字符串   str(x, 'utf-8')
加r和不加区别：'r'是防止字符转义，若路径中出现'\t'，不加r，'\t'会被转义。加'r'之后'\t'就能保留原有的样子。

# 列表用[ ]标识。是python最通用的复合数据类型，是有序的对象结合；列表alist=[4,5,7]
for i in range(len(alist)):
for i in alist:
for index,element in enumerate(alist):
for i in enumerate(alist):
for i in iter(alist):
a=['one','two','three']
逆序输出列表       for i in a[::-1]:
正序输出列表       for i in a:
按逗号分隔列表    ','.join(str(n) for n in a)
# 元组用"()"标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。不可变性atuple=(1,2,3)。
for i in range(len(atuple))
# 字典用大括号{}包裹，由索引(key)和它对应的值value组成，是无序的对象集合。adict={'x':1, 'y':2, 'z':3}
for key in  adict:
for key,value in  adict.items():
# Numpy数组   array([1, 2, 3])
# 集合 {1, 2, 3}（a = set()创建空集合只能用set创建，在Python中{}创建的是一个空的字典）
#不可变集合（frozen set）使用 frozenset 来进行创建：s=frozenset([1,2,3,'a',1])

字符串    s = "hello world"（不可变）
不想导入的属性名称加上一个下划线( _ )
dir(list)查看函数的功能 // dir(dict)
type(a) 查看a的类型
isinstance(i, int) 判断i是否为int类型
返回当前工作目录os.getcwd()  当前操作系统的换行符os.linesep
print squre.__doc__  //打印函数的注释
id(x)  返回变量x的内存地址
help(os)查看帮助，按q键退出
文件（*.py源码文件，由python程序解释；*.pyc源码经编译后生成的二进制字节码文件；*.pyo优化编译后的程序）
import this  # python彩蛋
默认第三方库安装路径/usr/lib64/python2.7/site-packages/PIL
字体元素路径：/usr/lib64/python2.7/site-packages/matplotlib/mpl-data/fonts/ttf
文件操作：打开；写入；读取；关闭；定位；改名；删除；写入时会把原来的覆盖掉。close() 方法允许调用多次
print(1,2+3)
list(range(0,4))
range(0,4)适用于for循环的变量控制
字符串以 16-bit Unicode 字符串存储
try except语句变化:  try:    ....    except Exception as e:    ....
s = "张三abc12"，b = s.encode( 编码方式)
b 就是 bytes 类型的数据
常用的编码方式为 ： "uft-16"    , "utf-8", "gbk", "gb2312", "ascii" , "latin1" 等，当字符串不能编码为指定的“编码方式”时，会引发异常




print(r'C:\some\name')
import xxx  # 模块导入，注意：自己创建模块时要注意命名，不能和python自带的模块名重名
import xxx as xx
from xxx import xx 
单引号和双引号区别：单引号（''）或双引号（""）都可表示字符串，多行字符串可以使用三重引号'''或 """ 



```



![08_03_python模块导入](./image/08_03_python模块导入.png)



![08_03python包导入用法](./image/08_03python包导入用法.png)



![08_03_python语法](./image/08_03_python语法.png)

![08_03_python函数入参.png](./image/08_03_python函数入参.png)

### 2.2 python网络框架

`4种Python网络框架：Django、Tornado、Flask(支持快速建站的框架)、Twisted(底层自定义协议网络框架)。`

`要性能Tornado 首选; Tornado 适合高度定制，适合访问量大，异步情况多的网站。也可以用于定制api服务。`

`要开发速度，Django; 适合初学者或小团队的快速开发，适合做管理类、博客类网站、或者功能十分复杂需求十分多的网站。`

- **Django框架（企业级开发框架）MVC框架**

  [Django文档](https://docs.djangoproject.com/zh-hans/2.0/)

  `url请求-->访问路由系统(负责分发请求到相应视图函数)-->视图函数(处理请求)-->DataBase(数据库操作数据生成对应页面返回给用户)`

  ```python
  # 安装 django相关命令
  pip3 install Django==2.1.1
  python3 
  sudo python3 -m pip install --upgrade pip //pip升级
  sudo pip3 install -U Django==2.0.0 //升级Django版本
  python3 -m django --version
  print(django.get_version())
  django-admin version
  django-admin help（备注：django-admin应该使用python3.6版本）
  
  # 创建项目(实战eg) https://docs.djangoproject.com/zh-hans/2.0/intro/tutorial01/
  django-admin startproject mysite //在当前目录下创建一个 mysite 目录
  python3 manage.py runserver
  python3 manage.py runserver xx.xx.xx.xx:8800
  访问:http://xx.xx.xx.xx:8800/
  备注：settings.py中如下进行设置ALLOWED_HOSTS = ['xx.xx.xx.xx']
  
  创建投票应用（重点关注 views.py和urls.py、models.py ）
  python3 manage.py startapp polls //创建应用，在 manage.py所在的文件夹下
  python3 manage.py runserver 127.0.0.1:8800
  http://127.0.0.1:8800/polls/
          
  python3 manage.py makemigrations polls //'polls.apps.PollsConfig'写入INSTALLED_APPS python3 manage.py sqlmigrate polls 0001
  python3 manage.py migrate //移植到数据库，在数据库创建对应的数据表
  python3 manage.py check //用于检查项目中的问题
  # python api交互
  python3 manage.py shell
  创建一个管理员账号： python3 manage.py createsuperuser 用户名·admin 密码123abc23邮箱admin@example.com 
  templates 目录：将页面的设计从代码中分离出来，Django会在templates目录里查找模板文件。
  python3 manage.py test polls //运行测试用例
  ```

- **Tornado框架（高并发处理框架）**

  [tornado用户指南](https://tornado-zh.readthedocs.io/zh/latest/guide.html)

  `Tornado 是一个Python web框架和异步网络库，通过使用非阻塞网络I/O, Tornado 可以支持上万级的连接，处理 长连接, WebSockets, 和其他需要与每个用户保持长久连接的应用`

  ```python
  # 安装：pip3 install tornado
  tornado利用epoll解决了c10k问题,用一个进程/线程来同时处理若干个连接的想法，减少了硬件资源的浪费。
  c10常见场景 两种高并发场景：用户量大，高并发。如秒杀抢购，双十一，618和春节抢票。大量的HTTP持久连接。
  核心模块 ioloop模块: tornado.ioloop.IOLoop.current().start() IOLoop类，current()类的一个方法 结果是返回一个当前线程的IOLoop的实例，start()也是IOLoop的方法，调用后开启循环。epoll负责监控。
  Tornado异步处理(请求特别耗时，把它丢在哪里，继续处理下一个请求，确保请求不会卡死)
  
  ```

  ![08_03_tornado](./image/08_03_tornado.png)

## 3、C

### 3.1 

